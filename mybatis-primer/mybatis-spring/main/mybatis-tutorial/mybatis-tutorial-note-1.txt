《mybatis 第一天 mybatis的基础知识》
传智.燕青
2018-2-1 09:54:07


--------------------------------------------------------

第一部分课程安排：

mybatis和springmvc通过订单商品的案例驱动

第一天：mybatis基础知识，是重点内容
    原生态jdbc程序问题总结

    mybatis框架原理（阅读源码，提升程序设计能力）

    mybatis入门程序
        用户的增、删、改、查

    mybatis开发dao两种方法：
        原始dao开发方法，程序需要编写dao接口和到实现类
        mybatis的mapper接口（相当于dao接口）代理开发方法

    mybatis配置文件SqlMapConfig.xml

    mybatis核心：
        mybatis输入映射
        mybatis输出映射

    mybatis的动态sql



第二天：mybatis高级知识
    订单商品数据模型分析
    高级结果集映射（一对一、一对多、多对多）
    mybatis延迟加载
    mybatis查询缓存（一级缓存、二级缓存）
    mybatis和spring整合
    mybatis逆向工程



--------------------------------------------------------
1 对原生态jdbc程序中问题总结
    (1) JdbcUtil程序
    (2) 问题总结
        a. 数据库连接，使用时创建，不使用时释放，对数据库进行频繁连接开启和关闭，
           造成数据库资源浪费，影响数据库性能
           改进：使用数据库连接池管理数据库连接

        b. 将sql硬编码到Java代码中，如果sql修改，需要重新编译Java代码，不利于
           系统维护。
           改进：将sql语句配置在xml配置文件中，即使sql变化，不需要对Java代码进行
           重新编译

        c. 向PreparedStatement中设置参数，将占位符号位置和参数值硬编码在Java代码
           中，不利于系统维护。
           改进：将sql语句以及占位符号和参数全部配置在xml中

        d. 从ResultSet遍历结果集数据时，将获取表的字段进行硬编码，不利于系统维护。
           改进：将查询的结果集，自动映射成Java对象。


--------------------------------------------------------
2 mybatis框架

(1) mybatis是什么?
    mybatis是对jdbc进一步的封装，是一个持久层框架。

    mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成
    （半自动化，大部分需要程序员编写sql）满足需要sql语句。

    mybatis可以将向preparedStatement中的输入参数自动进行输入映射，将查询结果集
    灵活映射成Java对象（输出映射）


(2) mybatis框架原理
    mybatis框架中的元素包括：
        SqlMapConfig.xml, SqlSessionFactory, SqlSession, Executor等

    SqlMapConfig.xml,
        是mybatis的全局配置文件，名称可以改变，
        配置数据源、事务等mybatis运行环境
        配置若干映射文件mapper.xml（映射文件，是配置了sql语句的文件）

    SqlSessionFactory,
        会话工厂，根据配置文件创建工厂，
        作用：创建SqlSession

    SqlSession,
        会话，是一个接口，面向开发者的接口
        作用：操作数据库，向数据库发出增删改查等SQL语句

    Executor,
        执行器，是一个接口（基本执行器和缓存执行器）
        作用：SqlSession内部通过执行器操作数据库


    mapped statement（底层封装对象）
        作用：对操作数据库存储封装，包括sql语句，输入参数、输出结果类型

    输入参数类型：
        Java简单类型
        HashMap
        pojo自定义对象

    输出结果类型：
        Java简单类型
        HashMap
        pojo自定义


--------------------------------------------------------
3 mybatis入门程序

3.1 功能需求
    -根据用户id（主键）查询用户信息
    -根据用户名模糊查询用户信息
    -添加用户
    -删除用户
    -更新用户

3.2 需要的Jar包
    -mysql-connector.jar
    -mybatis-3.x.jar

    IDEA中添加Jar包的一种方法是，File->project structure->Modules->Dependencies

3.3 log4j.properties
    -从mybatis manual文件中查找并拷贝
    -创建config源文件夹，和src同级别，即是在classpath目录下

    # Global logging configuration
    # log4j.rootLogger=ERROR, stdout
    # 在开发环境下，日志级别设置为DEBUG，生产环境设置为INFO或者ERROR
    log4j.rootLogger=DEBUG, stdout
    # MyBatis logging configuration...
    log4j.logger.org.mybatis.example.BlogMapper=TRACE
    # Console output...
    log4j.appender.stdout=org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n


3.4 SqlMapConfig.xml
    在classpath目录下，创建SqlMapConfig.xml配置文件，
    配置mybatis的运行环境，数据源、事务等，配置文件内容如下：

    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE configuration
            PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-config.dtd">
    <configuration>
        <!-- 和Spring整合后environments配置将废除 -->
        <environments default="mybatis_db"> <!-- 默认的数据库 -->
            <environment id="mybatis_db"> <!-- 指定的数据库 -->
                <transactionManager type="JDBC"/>
                <dataSource type="POOLED">
                    <!--<property name="driver" value="${driver}"/>-->
                    <!--<property name="url" value="${url}"/>-->
                    <!--<property name="username" value="${username}"/>-->
                    <!--<property name="password" value="${password}"/>-->

                    <property name="driver" value="com.mysql.jdbc.Driver"/>
                    <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis_db"/>
                    <property name="username" value="root"/>
                    <property name="password" value="root"/>
                </dataSource>
            </environment>
        </environments>
        <mappers>
            <mapper resource="sqlMap/User.xml"/>
        </mappers>
    </configuration>


3.5 根据用户id（主键）查询用户信息

3.5.1 创建PO类——User.java
    /**
     * User.java与mybatis-config/sqlmap/User.xml对应
     *
     * User.java中的字段和表user中的字段对应
     */
    public class User {
        private int id;
        private String username;
        private String gender;
        private Date brithday;
        private String addresss;
        // setters, getters


3.5.2 映射文件——User.xml
    映射文件命名：
        -User.xml（原始ibatis命名）
        -mapper代理开发映射文件名为XXXMapper.xml，比如UserMapper.xml、ItemsMapper.xml，
            在映射文件中配置sql语句。

    User.xml与POJO User.java对应

    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <!--
        namespace命名空间，作用就是对sql进行分类化管理，理解为sql隔离
        注意：使用mapper代理方法开发，namespace有特殊的作用，
    -->
    <mapper namespace="test">
        <!-- 在User.xml映射文件中配置很多sql语句-->
        <!-- 需求： 通过id查询用户表的记录 -->
        <!-- 通过select执行数据库查询
             id：表示映射文件中的sql语句，
                 将sql语句封装到mappedStatement对象中，所以将id称为statement的id

             parameterType：指定输入参数的类型，这里指定int型

             #{}，表示一个占位符号
             #{id}，其中id表示接收输入的参数，参数名称是id，
                    如果输入参数是简单类型，#{}中的参数名可以任意，可以是value或者其它
         -->

        <!-- 可以使用typeAlias定义别名，简化resultType-->
        <select id="findUserById" parameterType="int" resultType="User">
            <!--select id, role_name as roleName, note from t_role where id = #{id}-->
            select * from user where id = #{id}
        </select>
    </mapper>


3.5.3 通过SqlMapConfig.xml加载映射文件
    在SqlMapConfig.xml中加载User.xml
    <configuration>
        <mappers>
            <mapper resource="sqlMap/User.xml"/>
        </mappers>
    </configuration>


3.5.4 Dao程序编写
        /**
         * 根据id查询用户
         * 接收传入的参数，#{id}, #{value}相当于预编译语句中的占位符?
         * @throws IOException
         */
        @Test
        public void findUserByIdTest() throws IOException {
            // mybatis的全局配置文件SqlMapConfig.xml，在classpath路径下
            String resource = "SqlMapConfig.xml";
            // 使用Resources工具类读取全局配置文件
            InputStream inputStream = Resources.getResourceAsStream(resource);
            // 使用配置文件创建会话工厂SqlSessionFactory
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            // 使用会话工厂 SqlSessionFactory 创建会话 SqlSession
            SqlSession sqlSession = sqlSessionFactory.openSession();


            // 使用会话执行查询操作 selectOne(statementId, parameters)
            User user = sqlSession.selectOne("test.findUserById", 1);
            System.out.println(user);
            // 关闭会话
            sqlSession.close();
        }


3.6 根据用户名模糊查询用户信息（返回集合）
3.6.1 映射文件User.xml
    在User.xml中配置模糊查询用户的Statement，内容如下：
    <!--
        根据用户的名称模糊查询用户，可能返回多条
        resultType:
            返回多条记录，一条记录所对应的Java对象类型为resultType

        ${}:
            表示拼接sql语句，将接收到参数的内容不加任何修饰拼接在sql中
            ${}拼接sql，可能引起sql注入

        ${value}:
            接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value
    -->
    <select id="findUserByName" parameterType="java.lang.String"
            resultType="User">
        select * from user where username like '%${value}%'
    </select>


3.6.2 Dao程序
        /**
         * 模糊查询
         * 接收传入的参数并拼接sql语句，${value}，以原始的形式拼接到sql语句中
         * @throws IOException
         */
        @Test
        public void findUserByName() throws IOException {
            String resource = "SqlMapConfig.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            SqlSession sqlSession = sqlSessionFactory.openSession();

            List<User> list = sqlSession.selectList("test.findUserByName", "j");
            // System.out.println(Arrays.toString(list.toArray()));
            for (User user : list)
                System.out.println(user);
            sqlSession.close();
        }


3.7 添加用户
3.7.1 映射文件User.xml
    在User.xml中配置模糊查询用户的Statement，内容如下：

    <!--
        添加用户
        parameterType：指定输入参数类型是POJO
        #{}中指定POJO的属性名，接收到POJO对象的属性值，
            mybatis通过OGNL获取对象的属性值
    -->
    <insert id="insertUser" parameterType="User">
        insert into user(username, birthday, gender, address)
        values(#{username}, #{birthday}, #{gender}, #{address})
    </insert>


3.7.2 Dao程序编写
        private SqlSession openSession(){
            String resource = "SqlMapConfig.xml";
            SqlSession sqlSession = null;
            try {
                InputStream inputStream = Resources.getResourceAsStream(resource);
                SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
                sqlSession = sqlSessionFactory.openSession();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return sqlSession;
        }


        public void insertUser(User user){
            SqlSession sqlSession = openSession();
            sqlSession.insert("test.insertUser", user);
            sqlSession.commit();
            sqlSession.close();
        }

        @Test
        public void insertUser(){
            User user = new User();
            user.setUsername("zzz");
            user.setGender("1");
            user.setBirthday(new Date());
            user.setAddress("bj");
            insertUser(user);
        }


3.7.3 自增主键返回（返回到user对象中）
    mysql自增主键，执行insert提交之前自动生成一个自增主键。

    通过mysql函数获取到刚插入记录的自增主键：last_insert_id()，
    insert操作之后调用该函数。

    (1) 映射文件User.xml
       <!--
            添加User对象到数据库，并返回自增主键id

            parameterType，执行输入参数类型是POJO
            #{}中指定POJO的属性名，接收到POJO对象的属性值，
                mybatis通过OGNL获取对象的属性值
        -->
        <insert id="insertUserAndReturnId" parameterType="User">
            <!--
                将插入数据的自增主键返回，返回到user对象中

                select last_insert_id()
                得到刚insert操作插入记录的自增主键

                keyProperty: 将查询到主键值设置到parameterType指定的对象的那个属性，也即是user.id
                order: select last_insert_id()的执行顺序，相对于insert语句来说它的执行顺序
                resultType：执行select last_insert_id()的结果类型
            -->
            <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
                select last_insert_id()
            </selectKey>

            insert into user(username, birthday, gender, address)
            values(#{username}, #{birthday}, #{gender}, #{address})
        </insert>

    (2) Dao程序编写
       /**
         * 插入对象，并返回自增主键到对象属性中，user.id
         */
        public void insertUserAndReturnId(User user){
            SqlSession sqlSession = openSession();
            sqlSession.insert("test.insertUserAndReturnId", user);
            sqlSession.commit();
            sqlSession.close();
        }

        @Test
        public void insertUserAndReturnIdTest(){
            User user = new User();
            user.setUsername("aaa");
            user.setGender("0");
            user.setBirthday(new Date());
            user.setAddress("bj");
            insertUserAndReturnId(user);
            System.out.println("last_insert_id() = " + user.getId());
        }


3.7.4 非自增主键返回
使用mysql的uuid()函数生成主键，需要修改表中id字段类型为string，长度设置成35位。

执行思路：
    先通过uuid()函数查询到主键，将主键输入到sql语句中
    执行uuid()语句顺序相当于insert语句之前执行。
    (1) 映射文件User.xml
            <!--
                添加用户到数据库，返回uuid到userWithUuid.id
            -->
            <insert id="insertUserAndReturnUuid" parameterType="UserWithUuid">
                <selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String">
                    select uuid()
                </selectKey>
                insert into user_with_uuid(id, username, birthday, gender, address)
                values(#{id}, #{username}, #{birthday}, #{gender}, #{address})
            </insert>

    (2) Dao程序编写
        /**
         * 插入对象，并返回uuid主键到对象属性中，userWithUuid.id
         */
        public void insertUserAndReturnUuid(UserWithUuid userWithUuid){
            SqlSession sqlSession = openSession();
            sqlSession.insert("test.insertUserAndReturnUuid", userWithUuid);
            sqlSession.commit();
            sqlSession.close();
        }

        @Test
        public void insertUserAndReturnUuidTest(){
            UserWithUuid userWithUuid = new UserWithUuid();
            userWithUuid.setUsername("lyz-uuid");
            insertUserAndReturnUuid(userWithUuid);
            System.out.println("userWithUuid.id = " + userWithUuid.getId());
        }


3.8 删除用户
3.8.1 映射文件User.xml
        <!--
            删除用户
            根据id删除用户，需要传入id值
        -->
        <delete id="deleteUser" parameterType="java.lang.Integer">
            delete from user where id = #{id}
        </delete>

3.8.2 Dao程序编写
        public void deleteUser(int id){
            SqlSession sqlSession = openSession();
            sqlSession.delete("test.deleteUser", id);
            sqlSession.commit();
            sqlSession.close();
        }

        @Test
        public void deleteUserTest(){
            int id = 9;
            deleteUser(id);
        }


3.9 更新用户
3.9.1 映射文件User.xml
        <!--
            根据id更新用户
            分析：
                需要传入用户的id
                需要传入更新之后的用户信息
            parameterType：指定user对象，包括id和更新信息，注意，id必须存在
            ${id}：从输入user对象中获取id属性值
        -->
        <update id="updateUser" parameterType="User">
            update user set username=#{username}, birthday=#{birthday},
                gender=#{gender}, address=#{address} where id=#{id}
        </update>


3.9.2 Dao程序编写
        /**
         * 根据用户的标识id，和用户对象属性更新记录
         * @param user
         */
        public void updateUser(User user){
            SqlSession sqlSession = openSession();
            sqlSession.update("test.updateUser", user);
            sqlSession.commit();
            sqlSession.close();
        }

        @Test
        public void updateUserTest(){
            User user = new User();
            user.setId(7);
            user.setUsername("阿里多隆");
            updateUser(user);
        }


3.10 总结
3.10.1 parameterType
    在映射文件中的statement parameterType指定输入参数的类型

3.10.2 resultType
    在映射文件中的statement resultType指定输入结果的类型

3.10.3 #{}和${}
    #{}
        #{}表示一个占位符，
        #{}可以接收参数，可以是简单类型、POJO、HashMap
        如果接收简单类型，#{}中可以写成value或者其他名称
        如果接收POJO对象值，通过OGNL读取对象中属性值，通过对象.属性.属性...的方式获取对象属性值。

    ${}
        ${}表示一个拼接符号，可能引发sql注入，所以不建议使用${}
        ${}接收输入参数，类型可以使简单类型、POJO、HashMap
        如果接收简单类型，${}中只能是value
        如果接收POJO对象值，通过OGNL读取对象中的属性值，通过对象.属性.属性...的方式获取对象属性值。

3.10.4 selectOne和selectList
    selectOne
        表示查询出一条记录进行映射。

    selectList
        表示查询出一个列表（多条记录）进行映射。

3.10.5 insert, delete, update等方法


3.11 mybatis和hibernate本质区别和应用场景

hibernate
    是一个标准ORM框架（对象关系映射），入门门槛较高。
    不需要程序写SQL，框架会自动生成SQL语句。
    应用场景：
        适用于需求变化不多的中小型项目，比如后台管理系统、ERP、ORM，OA等。

mybatis
    专注于SQL本身，需要程序员自己编写SQL语句，SQL修改和优化比较方便。
    mybatis是一个不完全的ORM框架，开发者需要写SQL，
    mybatis可以实现输入映射和输出映射。
    应用场景：
        适用于需求变化较多的项目，比如互联网项目。

企业技术选型标准：
    以低成本高回报作为技术选型的原则，根据项目组的技术力量进行选择。


--------------------------------------------------------
4 mybatis开发Dao的两种方法
4.1 SqlSession使用范围
    4.1.1 SqlSessionFactoryBuilder
        作用：
            创建会话工厂SqlSessionFactory
        使用方法：
            String resource = "SqlMapConfig.xml";
            InputStream inputStream = new Resources.getResourceAsStream(resource);
            SqlSessionFactory factory =
                new SqlSessionFactoryBuilder().build(inputStream);
        说明：
            将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder。
            在需要创建SqlSessionFactory时，只需要new一次SqlSessionFactoryBuilder即可。

    4.1.2 SqlSessionFactory
        作用：
            SqlSessionFactory创建SqlSession
        使用方法：
            SqlSession sqlSession = sqlSessionFactory.openSession();
        说明：
            使用单例模式管理 sqlSessionFactory。
            mybatis和spring整合后，使用单例模式管理sqlSessionFactory。

    4.1.3 SqlSession
        作用：
            SqlSession是一个面向开发的接口，可以实现CURD。
        使用方法：
            T t = sqlSession.select("namespace.statementId", parameters);
            List<T> list = sqlSession.selectList("namespace.statementId", parameters);
            sqlSession.insert("namespace.statementId", parameters);
            sqlSession.update("namespace.statementId", parameters);
            sqlSession.delete("namespace.statementId", parameters);
        说明：
            SqlSession是线程不安全的，
            在SqlSession实现类中除了有接口中的方法（操作数据库的方法），
            还有数据域属性。
            SqlSession最佳应用场合是在方法体内，定义成局部变量使用。


    private SqlSession openSession(){
        String resource = "SqlMapConfig.xml";
        SqlSession sqlSession = null;
        try {
            InputStream inputStream = Resources.getResourceAsStream(resource);
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            sqlSession = sqlSessionFactory.openSession();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return sqlSession;
    }


4.2 原始Dao开发方法（开发者需要写Dao接口和Dao实现类）
    4.2.1 思路
        开发者需要写Dao接口和Dao的实现类
        需要向Dao实现类中注入SqlSessionFactory，在方法体内通过SqlSessionFactory创建SqlSession
        为什么不直接注入SqlSession？
            因为SqlSession不是线程安全的，在方法体内创建SqlSession对象更恰当

    4.2.2 Dao接口
        public interface UserDao {
            public User findUserById(int id) throws Exception;
            public void insertUser(User user) throws Exception;
            public void deleteUser(int id) throws Exception;
        }


    4.2.3 Dao接口的实现类
        public class UserDaoImpl implements UserDao {
            // 注入会话工厂，而不是会话，
            // 因为SqlSession是线程不安全，在方法体内创建更合适
            private SqlSessionFactory sqlSessionFactory;

            public UserDaoImpl(SqlSessionFactory sqlSessionFactory) {
                this.sqlSessionFactory = sqlSessionFactory;
            }

            @Override
            public User findUserById(int id) throws Exception {
                SqlSession sqlSession = sqlSessionFactory.openSession();
                User user = sqlSession.selectOne("test.findUserById", 1);
                sqlSession.close();
                return user;
            }

            @Override
            public void insertUser(User user) throws Exception {
                SqlSession sqlSession = sqlSessionFactory.openSession();
                sqlSession.update("test.updateUser", user);
                sqlSession.commit();
                sqlSession.close();
            }

            @Override
            public void deleteUser(int id) throws Exception {
                SqlSession sqlSession = sqlSessionFactory.openSession();
                sqlSession.update("test.deleteUser", 5);
                sqlSession.commit();
                sqlSession.close();
            }
        }

    4.2.4 单元测试程序
        public class UserDaoImplTest {
            private SqlSessionFactory sqlSessionFactory;

            @Before
            public void setUp() throws Exception{
                String resource = "SqlMapConfig.xml";
                InputStream inputStream = Resources.getResourceAsStream(resource);
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            }

            @Test
            public void testFindUserById() throws Exception{
                UserDao userDao = new UserDaoImpl(sqlSessionFactory);
                User user = userDao.findUserById(2);
                System.out.println("user = " + user);
            }
        }

    4.2.5 总结原始Dao开发问题
        (1) Dao接口实现类中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。
        (2) 调用SqlSession方法时将statement的id硬编码了
        (3) 调用SqlSession方法时传入的变量，由于SqlSession方法使用泛型，即使变量类型传入错误，
            在编译阶段也不会报错，不利于程序开发


4.3 mapper代理方法（开发者只需要编写mapper，相当于只写Dao接口，不写Dao接口的实现类）
    4.3.1 mapper代理开发规范
        开发者只需要编写mapper，相当于只写Dao接口，不写Dao接口的实现类
        但是Dao接口程序需要满足一定的规范
        另外，开发者仍需要编写映射文件mapper.xml
        也即是，mapper代理方法完成Dao功能需要编写Mapper接口XxxMapper.java和映射文件XxxMapper.xml
        其中，Mapper接口需要满足如下开发规范：

            (1) 在mapper.xml中namespace等于mapper接口的全限定名
                <mapper namespace="UserMapper">

            (2) mapper.java接口中的方法名和mapper.xml中statement的id一致
            (3) mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。
            (4) mapper.java接口中方法返回值类型和mapper.xml中statement的resultType指定的类型一致。
                User findUserById(int id) throws Exception;
                <select id="findUserById" parameterType="int" resultType="User">
                    select * from user where id = #{id}
                </select>

            小结以上四点开发规范：
                映射文件的命名空间和接口的全限定名相同
                （通过namespace关联Mapper.java接口和Mapper.xml映射文件）
                映射文件中的statement语句中id、parameterType、resultType
                    和接口中的方法名、方法参数和方法返回类型分别对应相同。

    说明：
        满足以上四点开发规范，mybatis可以根据mapper.java和mapper.xml生成如下代码：
            User user = sqlSession.selectOne("test.findUserById", id);
            sqlSession.insert("test.insertUser", user);
            ...

        实现过程描述：
            (1) XxxMapper.xml映射文件中namespace是XxxMapper.java的全限定名，
                <mapper namespace="UserMapper">
                这样可以关联XxxMapper.xml和XxxMapper.java文件

            (2) 结合XxxMapper.xml中的statement和XxxMapper.java中的抽象方法
                生成sqlSession.selectOne("namespace.method", parameters)等方法


    4.3.2 接口mapper.java和映射文件mapper.xml
        接口mapper.xml
            public interface UserMapper{
                User findUserById(int id) throws Exception;
            }

        映射文件mapper.xml
            <select id="findUserById" parameterType="int"
                resultType="User">
                select * from user where id=#{id}
            </select>

    4.3.3 在SqlMapConfig.xml中加载映射文件mapper.xml
        <mappers>
            <!--
                sqlMap是classpath路径下（跟src同级别的源代码文件夹）的文件夹，
                专门保存mapper.xml
            -->
            <mapper resource="sqlMap/User.xml">
            <mapper resource="mapper/UserMapper.xml">
        </mappers>

    4.3.4 测试
        public class UserMapperTest {
            private SqlSessionFactory sqlSessionFactory;

            @Before
            public void setUp() throws Exception{
                String resource = "SqlMapConfig.xml";
                InputStream inputStream = Resources.getResourceAsStream(resource);
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            }

            @Test
            public void testFindUserById() throws Exception {
                SqlSession sqlSession = sqlSessionFactory.openSession();

                // mybatis生成XxxMapper.java接口的代理对象
                // sqlSession.getMapper(Class<T> clazz)
                UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

                User user = userMapper.findUserById(1);
                System.out.println(user);
            }
        }


    4.3.6 一些问题总结
        (1) 代理对象内部调用selectOne或selectList
            如果XxxMapper方法返回值是单个POJO对象（非集合对象），代理对象内部
                通过selectOne查询数据库。
            如果XxxMapper方法返回集合对象，代理对象内部通过selectList查询数据库。

        (2) XxxMapper.java接口方法参数只能有一个是否影响系统开发
            XxxMapper接口方法参数只能有一个，不利于系统扩展维护。
            系统框架中，Dao层的代码是被业务层公用的。
            即使XxxMapper.java接口只有一个参数，可以使用包装类型POJO满足不同的业务方法的需求。
            注意：
                持久层方法的参数可以为包装类型、Map....，
                service方法中建议不要使用包装类型，不利于业务层的可扩展性


--------------------------------------------------------
5 SqlMapConfig.xml

    mybatis的全局配置文件SqlMapConfig.xml，配置内容如下：
    properties，属性
    settings，全局配置参数
    typeAliases，类别别名
    typeHandlers，类别处理器
    objectFactory，对象工厂
    plugins，插件
    environments，环境集合属性对象
        environment，环境子属性对象
            transactionManager，事务管理
            dataSource，数据源
    mappers，映射器

5.1 properties 属性
    需求：
        将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中
        加载db.properties的属性值。
        在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。

        将数据库连接参数只配置在db.properties中，
        原因：
            方便对参数进行统一管理，其他xml可以引用该db.properties


    db.properties属性文件
        jdbc.driver=com.mysql.Driver
        jdbc.url=jdbc:mysql://localhost:3306/mybatis-db
        jdbc.username=root
        jdbc.password=root


    在sqlMapConfig.xml加载属性文件
    <properties resource="db.properties"></properties>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC" />
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}" />
                <property name="url" value="${jdbc.url}" />
                <property name="username" value="${jdbc.username}" />
                <property name="username" value="${jdbc.password}" />
            <dataSource>
        <environment>
    </environments>

    properties特性：
    # 读源代码
    注意：Mybatis将按照下面的顺序加载属性
        (1) 在properties元素体内定义的属性首先被读取
        (2) 然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性
        (3) 最后读取parameterType传递的属性，它会覆盖已读取的同名属性
    建议：
        不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。
        在properties文件中定义属性名要有一定的特殊性，比如加上统一的前缀 XX.yy.zz。


5.2 settings全局参数配置
    mybatis框架在运行时可以调整一些运行参数。
    比如，开启二级缓存、开启延迟加载。

    全局参数将会影响mybatis的运行行为：
        mybatis-settings.xlsx


5.3 typeAlias（别名，重要）
    5.3.1 需求
        在mapper.xml中，定义很多的statement，statement需要parameterType和
        resultType分别指定输入参数的类型、输出结果的类型。

        问题：
            如果在指定类型时，输入类型全路径，不便于开发。
        解决方法：
            可以针对parameterType和resultType指定的类型定义一些别名，
            在mapper.xml中通过别名定义，方便开发。
            不用在每一个引用类型之处都写长长的字符串了，提高了代码的可读性。

    5.3.2 mybatis默认支持别名
        alias       映射的类型
        _byte       byte
        _short      short
        _int        int
        _integer    int
        _long       long
        _float      float
        _double     double
        _boolean    boolean

        byte        Byte
        short       Short
        int         Integer
        integer     Integer
        long        Long
        float       Float
        double      Double
        boolean     Boolean

        string      String
        date        Date
        decimal     BigDecimal
        bigdecimal  BigDecimal

    5.3.3 自定义别名
        (1) 单个别名定义
            <typeAliases>
                <!--
                    type：类型的全限定名
                    alias：别名，外号
                -->
                <typeAlias type="User" alias="user" />
            </typeAliases>

            引用别名：
                <select id="findUserById" parameterType="int" resultType="user">
                    select * from user where id=#{value}
                </select>

        (2) 批量定义别名（常用）
            <!--
                批量定义别名
                指定包名，
                    mybatis自动扫描包中的po类，自动定义别名，
                    别名就是简单类名，首写字母不区分大小写
            -->
            <package name="org.alpha.mybatis.po">


5.4 typeHandlers（类型处理器）
    mybatis中通过typeHandlers完成jdbc类型（数据库类型）和Java类型转换。

    通常，mybatis提供的类型处理器满足开发需要，不需要自定义。
    mybatis支持类型处理器：
        类型处理器               JDBC类型（数据库）               Java类型
        ByteTypeHandler         任何兼容的数字或字节类型          byte,Byte
        ShortTypeHandler        任何兼容的数字或短整型            short,Short
        IntegerTypeHandler
        LongTypeHandler
        FloatTypeHandler
        DoubleTypeHandler
        BigDecimalHandler

        StringTypeHandler
        NStringTypeHandler

        ClobTypeHandler
        NClobTypeHandler

        ByteArrayHandler
        BlobTypeHandler

        DateTypeHandler
        DateOnlyTypeHandler
        TimeOnlyTypeHandler
        SqlTimestampTypeHandler
        SqlDateTypeHandler
        SqlTimeTypeHandler

        ObjectTypeHandler
        EnumTypeHandler


5.5 mappers（映射配置）
    5.5.1 通过resource加载单个映射文件
        通过mapper的resource属性一次加载一个映射文件
        <mapper resource="mapper/UserMapper.xml" />

    5.5.2 通过mapper接口加载单个mapper
        <mapper class="UserMapper">
        按照上面的规范，将mapper.java和mapper.xml放在一个目录，且同名
            org.alpha.mybatis.mapper
                -UserMapper.java
                -UserMapper.xml

    5.5.3 批量加载mapper（推荐使用）
        批量加载mapper：
            指定mapper接口的包名，mybatis自动扫描包下面所有Mapper接口并加载。
        遵循一定规范：
            使用Mapper代理方法
            需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录中
        <mappers>
            <package name="org.alpha.mybatis.mapper" />
        </mappers>


--------------------------------------------------------
6 输入映射
    通过parameterType指定输入参数的类型，类型可以是简单类型、HashMap、POJO包装类型。
    vo   - 视图层对象
    po   - 持久层对象
    pojo - 中间层的JavaBean

6.1 传递基本类型

6.2 传递POJO的包装类型
    6.2.1 需求
        完成用户信息的综合查询，需要传入查询条件较复杂，比如可能包括用户信息以及商品和订单信息等。

    6.2.2 定义包装类型POJO
        po          持久层对象          User.java             跟数据库中的表对应
        pojo        中间层的JavaBean    UserCustom.java      对表对应的对象进行包装，添加额外的属性
        vo          视图层对象          UserQueryVo.java     根据视图层的需求，在中间层的基础进一步添加额外的属性
        其中，
            pojo继承po，vo包装pojo
            视图层仅需要一个Vo对象可以完成各种查询和显示
        User{
            name;
            gender;
            age;
        }

        UserCustom extends User{
            // nickname
        }

        UserVo{
            UserCustom userCustom;
        }


        针对以上需求，建议使用自定义的包装类型POJO。
        在包装类型的POJO中将复杂的查询条件包装进去。
        public class UserQueryVo{
            // 在这里包装所需要的查询条件，1-3

            // 1.用户查询条件
            private UserCustom userCustom;
            public UserCustom getUserCustom{
                return userCustom;
            }
            public void setUserCustom(UserCustom userCustom){
                this.userCustom = userCustom;
            }

            // 2. 商品查询条件
            private GoodCustom goodCustom;
            // setter and getter

            // 3. 订单的查询条件
            private ItemCustom iteCustom;
            // setter and getter
        }

    6.2.3 映射文件mapper.xml
        在UserMapper.xml中定义用户信息综合查询
        （查询条件复杂，通过高级查询进行关联查询）
        <!--
            用户信息综合查询
            #{userCustom.gender}，取出UserQueryVo.UserCustom.gender
            #{userCustom.username}，取出UserQueryVo.UserCustom.username
        -->
        <select id="findUserList" parameterType="UserQueryVo"
                resultType="UserCustom">
            select * from user where user.gender = #{userCustom.gender}
                and user.username like '%${userCustom.username}%'
        </select>

    6.2.4 Mapper接口文件
        // 用户信息综合查询
        public List<UserCustom>  findUserList(UserQueryVo userQueryVo)
            throws Exception;


    6.2.5 测试代码
        @Test
        public void testFindUerList() throws Exception{
            SqlSession sqlSession = sqlSessionFactory.openSession();
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

            UserQueryVo userQueryVo = new UserQueryVo();
            UserCustom userCustom = new UserCustom();
            userCustom.setSex("1");
            userCustom.setUsername("New Name");
            userQueryVo.setUserCustom(userCustom);

            List<UserCustom> list = userMapper.findUserList(userQueryVo);
        }


--------------------------------------------------------
7 输出映射
7.1 resultType
    使用resultType进行输出映射，只有查询出来的列名和POJO中的属性名一致，
    该列才可以映射成功

    如果查询出来的别名和POJO中的属性名全部不一致，没有创建POJO对象。
    只要查询出来的列名和POJO中的属性有一个一致，就会创建POJO对象。

    7.1.1 输出简单类型
        (1) 用户信息的综合查询列表总数，通过查询总数和用户综合查询列表才可以实现分页。
        (2) 映射文件mapper.xml
            <select id="findUserCount" parameterType="UserQueryVo"
                resultType="int">
                select count(*) from user where user.gender  #{userCustom.gender}
                    and user.username like '%${userCustom.username}%'
            </select>
        (3) Mapper文件mapper.java
            // 用户信息综合查询总数
            public int findUserCount(UserQueryVo userQueryVo) throws Exception;
        (4) 小结
                查询结果集只有一行一列，可以使用简单类型进行输出映射。

    7.1.2 输出pojo对象和pojo列表
        输出结果是单个POJO对象或者列表，映射文件中的statement的resultType均指定为
            该POJO的全限定名或别名。

        (1) 输出单个POJO对象，方法返回值是单个对象类型
            public User findUserById(itn id) throws Exception;
        (2) 输出POJO对象list，方法返回值是List<POJO>
            public List<UserCustom> findUserByName(String username) throws Exception;

        生成的动态代理对象根据mapper方法的返回值确定是调用selectOne还是selectList.

7.2 resultMap
    mybatis中使用resultMap完成高级输出结果映射。
    7.2.1 resultMap使用方法
        如果查询出来的猎命和pojo的属性名不一致，通过定义一个resultMap对列名和POJO属性名之间
            作一个映射关系。
        (1) 定义resultMap
        (2) 使用resultMap作为statement的输出映射类型


    7.2.2 将下面的sql使用User完成映射
        select id id_, username username_ from user where id = #{value}
        User类中属性名和上面查询列名不一致。

        (1) 定义resultMap
            <!--
                使用resultMap转换查询结果
                    当类的属性名和对应表的列名不一致时，使用resultMap作为桥梁，
                    将表中的查询结果转换为对应的类

                type, resultMap最终映射的Java对象类型，可以使用别名
                id, resultMap的唯一标识
            -->
            <resultMap type="User" id="userResultMap">
                <!--
                    id, 表示查询结果集中唯一标识
                    column, 查询结果的列名（或别名）
                    property, type指定的POJO类型中的属性名
                -->
                <id column="id_" property="id" />
                <result column="username_" property="username" />
            </resultMap>


        (2) 使用resultMap作为statement的输出映射类型
            <!--
                使用resultMap作为statement的输出映射类型
                resultMap，指定定义的resultMap的id，
                           如果这个resultMap在其它的mapper文件，前面需要添加namespace
            -->
            <select id="findUserByIdResultMap" parameterType="int"
                resultMap="userResultMap">
                select id id_, username username_ from user where id=#{value}
            </select>

        (3) Mapper.java
            // 根据id查询用户，使用resultMap输出
            User findUserByIdResultMap(int id) throws Exception;

        (4) 测试
            /**
             * 测试userMapper.findUserByIdResultMap方法
             */
            @Test
            public void testFindUserByIdResultMap() throws Exception {
                SqlSession sqlSession = sqlSessionFactory.openSession();
                UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
                int id = 1;
                User user = userMapper.findUserByIdResultMap(id);
                System.out.println(user);
            }

7.3 查询结果集到对象的一次性的映射
    resultMap是对结果集到对象映射关系的抽取，提高了代码复用性
    而通过为查询结果起别名的方式需要在每一个statement中重复编写
    (1) 映射文件mapper.xml
        <!--
            通过对查询结果起别名的方式，使查询结果的列名和POJO属性名一致，
            完成数据表到对象的映射
        -->
        <select id="findUserByIdWithAlias" parameterType="int"
                resultType="User">
            <!--select id as id, user_name as username from user where id=#{value}-->
            select id as id, username as username from user where id=#{value}
        </select>

    (2) mapper.xml
        User findUserByIdWithAlias(int id) throws Exception;

7.4 小结
    使用resultType进行输出映射，
        只有查询结果的列名或别名和POJO的属性名一致，该列才可以映射成功。
        如果查询结果的列名和POJO的属性名不一致，通过对列名起别名或者通过定义resultMap的方式
            实现查询结果和POJO属性名之间的映射。


--------------------------------------------------------
8 动态SQL

8.1 动态SQL是什么？
    mybatis的核心是对SQL语句进行灵活操作，通过表达式进行判断，对SQL进行灵活拼接、组装。

8.2 需求
    用户信息综合查询列表和哟用户信息查询列表总数这两个statement的定义使用动态SQL。
    对查询条件进行判断，如果输入参数不为空才进行查询条件拼接。

8.3 映射文件mapper.xml
        <!--
            使用动态SQL完成参数检查
            UserQueryVo，查询包装类型
        -->
        <select id="findUserListWithDynamicSql" parameterType="UserQueryVo"
                resultType="UserCustom">
            select * from user
            <where>
                <!--
                    where 可以自动去掉条件中的第一个and
                -->
                <if test="userCustom!=null">
                    <if test="userCustom.gender!=null and userCustom.gender!=''">
                        and gender=#{userCustom.gender}
                    </if>
                    <if test="userCustom.username!=null and userCustom.username!=''">
                        and username like '%${userCustom.username}%'
                    </if>
                </if>
            </where>
        </select>

        <select id="findUserCountWithDynamicSql" parameterType="UserQueryVo"
                resultType="int">
            select count(*) from user
            <where>
                <if test="userCustom!=null">
                    <if test="userCustom.gender!=null and userCustom.gender!=''">
                        and gender=#{userCustom.gender}
                    </if>
                    <if test="userCustom.username!=null and userCustom.username!=''">
                        and username like '%${userCustom.username}%'
                    </if>
                </if>
            </where>
        </select>

8.4 Mapper.class
        List<UserCustom> findUserListWithDynamicSql(UserQueryVo userQueryVo) throws Exception;
        int findUserCountWithDynamicSql(UserQueryVo userQueryVo) throws Exception;


8.5 测试代码
        /**
         * 测试方法 userMapper.findUserListWithDynamicSql
         */
        @Test
        public void testFindUserListWithDynamicSql() throws Exception {
            SqlSession sqlSession = sqlSessionFactory.openSession();
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

            UserQueryVo userQueryVo = new UserQueryVo();
            UserCustom userCustom = new UserCustom();
            userCustom.setGender("1");
            userCustom.setUsername("l");
            userQueryVo.setUserCustom(userCustom);

            List<UserCustom> list = userMapper.findUserListWithDynamicSql(userQueryVo);
            System.out.println(list);
        }


        /**
         * 测试方法 userMapper.findUserCountWithDynamicSql
         * @throws Exception
         */
        @Test
        public void testFindUserCountWithDynamicSql() throws Exception {
            SqlSession sqlSession = sqlSessionFactory.openSession();
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

            UserQueryVo userQueryVo = new UserQueryVo();
            UserCustom userCustom = new UserCustom();
            userCustom.setGender("1");
            // 动态sql不会拼接 userCustom.username
            // userCustom.setUsername("l");
            userQueryVo.setUserCustom(userCustom);

            int count = userMapper.findUserCountWithDynamicSql(userQueryVo);
            System.out.println(count);
        }

8.6 SQL片段
    8.6.1 需求
        将上面实现的动态SQL判断代码抽取出来，组成一个SQL片段。
        多个statement可以引用该SQL片段，提高了代码的复用性。

    8.6.2 定义sql片段
        <!--
            定义SQL片段
                id：
                    SQL片段的唯一标识
                经验：
                    基于单表定义SQL片段，这样SQL判断的可重用性较高
                    在SQL片段中不要包括where
        -->
        <sql id="query_user_where">
            <if test="userCustom!=null">
                <if test="userCustom.gender!=null and userCustom.gender!=''">
                    and gender=#{userCustom.gender}
                </if>
                <if test="userCustom.username!=null and userCustom.username!=''">
                    and username='%${userCustom.username}%'
                </if>
            </if>
        </sql>

    8.6.3 引用SQL片段
        在mapper.xml中定义的statement中引用SQL片段
        <select id="findUserCountWithSqlCode" parameterType="UserQueryVo"
                resultType="int">
            select count(*) from user
            <where>
                <!--<if test="userCustom!=null">-->
                    <!--<if test="userCustom.gender!=null and userCustom.gender!=''">-->
                        <!--and gender=#{userCustom.gender}-->
                    <!--</if>-->
                    <!--<if test="userCustom.username!=null and userCustom.username!=''">-->
                        <!--and username like '%${userCustom.username}%'-->
                    <!--</if>-->
                <!--</if>-->
                <!-- 引用SQL片段的id，如果refid指定的id不在本mapper文件中，需要在前面加namespace-->
                <include refid="query_user_where" />
                <!-- 在此处可以引用其他的SQL引用 -->
            </where>
        </select>

    8.6.4 Mapper.java
        int findUserCountWithSqlCode(UserQueryVo userQueryVo) throws Exception;

    8.6.5 测试
        /**
         * 测试方法 userMapper.findUserCountWithSqlCode
         * @throws Exception 异常
         */
        @Test
        public void testFindUserCountWithSqlCode() throws Exception {
            SqlSession sqlSession = sqlSessionFactory.openSession();
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

            UserQueryVo userQueryVo = new UserQueryVo();
            UserCustom userCustom = new UserCustom();
            userCustom.setGender("1");
            // userCustom.setUsername("l");
            userQueryVo.setUserCustom(userCustom);

            int count = userMapper.findUserCountWithSqlCode(userQueryVo);
            System.out.println(count);
        }

8.7 foreach
    向SQL传递数据或List，mybatis使用foreach解析

    8.7.1 需求
        在用户查询列表和查询总数的statement中增加多个id输入查询。
        SQL语句如下：
            (1) select * from user where id=1 or id=10 or id=16
            (2) select * from user where id in(1, 10, 16)

    8.7.2 在输入参数类型中添加List<Integer> ids传入多个id
        public class UserQueryVo{
            // 传入多个id
            private List<Integer> ids;
        }

    8.7.3 映射文件mapper.xml
        <!--
            使用mybatis的foreach遍历数组或者List类型的参数，然后拼接SQL
        -->
        <select id="findUserListWithForeach" parameterType="UserQueryVo"
            resultType="UserCustom">
            select * from user
            <where>
                <if test="userCustom!=null">

                    <if test="userCustom.gender!=null and userCustom.gender!=''">
                        and gender=#{userCustom.gender}
                    </if>

                    <if test="userCustom.username!=null and userCustom.username!=''">
                        <!--DEBUG [main] - ==>  Preparing: select * from user WHERE gender=?
                                and username like '%l%'
                                and ( id=? or id=? or id=? )-->
                        <!--DEBUG [main] - ==> Parameters: 1(String), 1(Integer), 3(Integer), 5(Integer)-->
                        and username like '%${userCustom.username}%'
                    </if>
                </if>

                <if test="ids!=null">
                    <!-- and (id=1 or id=10 or id=16) -->
                    <!--
                        使用foreach遍历传入ids
                        collection：
                            指定输入对象中集合属性
                        item：
                            集合中的元素
                        open：
                            开始遍历时拼接的串
                        close：
                            结束遍历时拼接的串
                        separator：
                            分隔符
                    -->
                    <foreach collection="ids"
                             item="user_id"
                             open="and ("
                             close=")"
                             separator="or">
                        id=#{user_id}
                    </foreach>
                </if>
            </where>
        </select>

        8.7.4 Mapper.java
            List<UserCustom> findUserListWithForeach(UserQueryVo userQueryVo) throws Exception;

        8.7.5 测试代码
            /**
             * 测试方法 userMapper.findUserListWithForeach
             * @throws Exception 异常
             */
            @Test
            public void testFindUserListWithForeach() throws Exception {
                SqlSession sqlSession = sqlSessionFactory.openSession();
                UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

                UserQueryVo userQueryVo = new UserQueryVo();

                UserCustom userCustom = new UserCustom();
                userCustom.setGender("1");
                userCustom.setUsername("l");
                userQueryVo.setUserCustom(userCustom);

                // List<Integer> ids = Arrays.asList(1, 3, 5);
                List<Integer> ids = Arrays.asList(1, 3);
                userQueryVo.setIds(ids);

                List<UserCustom> list = userMapper.findUserListWithForeach(userQueryVo);
                System.out.println(list);
            }


        8.1.5 拼接 in (1, 3, 5)
            <!--
                实现 and id in(1, 3, 5)
            -->
            <foreach collection="ids" item="user_id"
                     open="and id in("
                     close=")"
                     separator=","
            >
                #{user_id}
            </foreach>


2018-2-9 15:00:55

--------------------------------------------------------