Kafka-note
@date 2018-8-17 19:09:45


kafka与传统MQ的对比
传统的消息系统有两种模型, 队列模型和发布订阅模型,
在订阅模型中, 一群消费者从服务器读取记录, 每条记录会分发到其中一个消费者中, 在发布和订阅模型中, 记录分发给所有的消费者。
这两种模型都有各自的优缺点,
	队列的优点是它允许你把数据处理提交到多个消费者实例中, 适用于数据处理的水平扩展,
		但是队列不是多订阅的,一旦其中的一个消费者读取了记录, 则记录就算处理过了。
	在发布订阅模型中允许你广播到记录到不同的订阅者上, 但是这种方式没法对不同的订阅者进行负载均摊


Kafka
	Producer即生产者，向Kafka集群发送消息，在发送消息之前，会对消息进行分类，即Topic，
		上图展示了两个producer发送了分类为topic1的消息，另外一个发送了topic2的消息。

　　Topic即主题，通过对消息指定主题可以将消息分类，消费者可以只关注自己需要的Topic中的消息。

　　Consumer即消费者，消费者通过与kafka集群建立长连接的方式，不断地从集群中拉取消息，然后可以对这些消息进行处理。

    分区
    	谈到kafka的存储，就不得不提到分区，即partitions，
    	创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，
    	kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。
    	在每个分区中，消息以顺序存储，最晚接收的的消息会最后被消费。


    消息存储策略
    	指定分区、均衡策略、随机均衡策略

    	生产者在向kafka集群发送消息的时候，可以通过指定分区来发送到指定的分区中
　　　　 也可以通过指定均衡策略来将消息发送到不同的分区中
　　　　 如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的分区中

	与消费者的交互
	    在消费者消费消息时，kafka使用offset来记录当前消费的位置
　　　　 	在kafka的设计中，可以有多个不同的group来同时消费同一个topic下的消息，
			如图，我们有两个不同的group同时消费，他们的的消费的记录位置offset各不项目，不互相干扰。
　　　　 对于一个group而言，消费者的数量不应该多于分区的数量，
			在一个group中，每个分区至多只能绑定到一个消费者上，即一个消费者可以消费多个分区，一个分区只能给一个消费者消费
　　　　 	若一个group中的消费者数量大于分区数量的话，多余的消费者将不会收到任何消息。


kafka 相关名词
1.producer：
　　消息生产者，发布消息到 kafka 集群的终端或服务。
2.broker：
　　kafka 集群中包含的服务器。
3.topic：
　　每条发布到 kafka 集群的消息属于的类别，即 kafka 是面向 topic 的。
4.partition：
　　partition 是物理上的概念，每个 topic 包含一个或多个 partition。kafka 分配的单位是 partition。
5.consumer：
　　从 kafka 集群中消费消息的终端或服务。
6.Consumer group：
　　high-level consumer API 中，每个 consumer 都属于一个 consumer group，每条消息只能被 consumer group 中的一个 Consumer 消费，但可以被多个 consumer group 消费。
7.replica：
　　partition 的副本，保障 partition 的高可用。
8.leader：
　　replica 中的一个角色， producer 和 consumer 只跟 leader 交互。
9.follower：
　　replica 中的一个角色，从 leader 中复制数据。
10.controller：
　　kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover。
12.zookeeper：
　　kafka 通过 zookeeper 来存储集群的 meta 信息。

信息是一个字节数组，程序员可以在这些字节数组中存储任何对象，支持的数据格式包括 String、JSON、Avro。



